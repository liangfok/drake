#include "drake/automotive/maliput/api/road_network.h"

#include <utility>

#include "drake/automotive/maliput/api/lane.h"
#include "drake/common/drake_throw.h"

namespace drake {
namespace maliput {
namespace api {

RoadNetwork::RoadNetwork(
    std::unique_ptr<const RoadGeometry> road_geometry,
    std::unique_ptr<const rules::RoadRulebook> rulebook,
    std::vector<std::unique_ptr<Intersection>> intersections,
    std::unique_ptr<rules::RightOfWayPhaseBook> phase_book,
    std::unique_ptr<rules::RightOfWayStateProvider> state_provider,
    std::unique_ptr<rules::RightOfWayPhaseProvider> phase_provider,
    std::vector<rules::SpeedLimitRule> speed_limits,
    std::vector<rules::DirectionUsageRule> direction_usage_rules)
    : road_geometry_(std::move(road_geometry)),
      rulebook_(std::move(rulebook)),
      intersections_(std::move(intersections)),
      phase_book_(std::move(phase_book)),
      state_provider_(std::move(state_provider)),
      phase_provider_(std::move(phase_provider)),
      speed_limits_(std::move(speed_limits)),
      direction_usage_rules_(std::move(direction_usage_rules)) {
  DRAKE_THROW_UNLESS(road_geometry_.get() != nullptr);
  DRAKE_THROW_UNLESS(rulebook_.get() != nullptr);
  DRAKE_THROW_UNLESS(phase_book_.get() != nullptr);
  DRAKE_THROW_UNLESS(state_provider_.get() != nullptr);
  DRAKE_THROW_UNLESS(phase_provider_.get() != nullptr);
  for (int i = 0; i < static_cast<int>(intersections_.size()); ++i) {
    intersections_map_[intersections_.at(i)->id()] = intersections_.at(i).get();
  }

  for (int ji = 0; ji < road_geometry_->num_junctions(); ++ji) {
    const api::Junction* junction = road_geometry->junction(ji);
    for (int si = 0; si < junction->num_segments(); ++si) {
      const api::Segment* segment = junction->segment(si);
      for (int li = 0; li < segment->num_lanes(); ++li) {
        const api::Lane* lane = segment->lane(li);
        auto RuleIdMatchesLaneId = [lane](rules::DirectionUsageRule rule) {
          return rule.zone().lane_id() == lane->id();
        };
        auto lane_rule = std::find_if(direction_usage_rules_.begin(),
            direction_usage_rules_.end(), RuleIdMatchesLaneId);
        if (lane_rule == direction_usage_rules_.end()) {
          throw std::runtime_error(
            "All Lanes must be present in a DirectionUsageRule");
        }
      }
    }
  }
}

optional<const Intersection*> RoadNetwork::intersection(
    const Intersection::Id& id) const {
  if (intersections_map_.find(id) == intersections_map_.end()) {
    return nullopt;
  }
  return intersections_map_.at(id);
}

}  // namespace api
}  // namespace maliput
}  // namespace drake
